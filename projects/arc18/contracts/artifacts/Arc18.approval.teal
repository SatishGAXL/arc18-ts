#pragma version 10

// This TEAL was generated by TEALScript v0.97.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// optInToApplication()void
*abi_route_optInToApplication:
	// execute optInToApplication()void
	callsub optInToApplication
	int 1
	return

// optInToApplication(): void
optInToApplication:
	proto 0 0
	retsub

// from_administrator(): boolean
from_administrator:
	proto 0 1

	// *if0_condition
	// contracts\Arc18.algo.ts:25
	// this.administrator.value == this.txn.sender
	byte 0x61646d696e6973747261746f72 // "administrator"
	app_global_get
	txn Sender
	==
	bz *if0_else

	// *if0_consequent
	// contracts\Arc18.algo.ts:26
	// return true;
	int 1
	retsub
	b *if0_end

*if0_else:
	// contracts\Arc18.algo.ts:28
	// return false;
	int 0
	retsub

*if0_end:
	retsub

// royalty_amount(amount: uint64, royalty_basis: uint64): uint64
royalty_amount:
	proto 2 1

	// contracts\Arc18.algo.ts:33
	// return (amount * royalty_basis) / max_royalty_basis;
	frame_dig -1 // amount: uint64
	frame_dig -2 // royalty_basis: uint64
	*
	int 10000
	/
	retsub

// pay_algos(amount: uint64, owner: Address, royalty_receiver: Address, royalty_basis: uint64): void
pay_algos:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Arc18.algo.ts:37
	// royalty_amount = this.royalty_amount(amount, royalty_basis)
	frame_dig -4 // royalty_basis: uint64
	frame_dig -1 // amount: uint64
	callsub royalty_amount
	frame_bury 0 // royalty_amount: uint64

	// contracts\Arc18.algo.ts:38
	// sendPayment({ receiver: owner, amount: amount - royalty_amount, fee: 0 })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:38
	// receiver: owner
	frame_dig -2 // owner: Address
	itxn_field Receiver

	// contracts\Arc18.algo.ts:38
	// amount: amount - royalty_amount
	frame_dig -1 // amount: uint64
	frame_dig 0 // royalty_amount: uint64
	-
	itxn_field Amount

	// contracts\Arc18.algo.ts:38
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if1_condition
	// contracts\Arc18.algo.ts:39
	// royalty_amount > 0
	frame_dig 0 // royalty_amount: uint64
	int 0
	>
	bz *if1_end

	// *if1_consequent
	// contracts\Arc18.algo.ts:40
	// sendPayment({ receiver: royalty_receiver, amount: royalty_amount, fee: 0 })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:40
	// receiver: royalty_receiver
	frame_dig -3 // royalty_receiver: Address
	itxn_field Receiver

	// contracts\Arc18.algo.ts:40
	// amount: royalty_amount
	frame_dig 0 // royalty_amount: uint64
	itxn_field Amount

	// contracts\Arc18.algo.ts:40
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if1_end:
	retsub

// pay_assets(asset: AssetID, amount: uint64, owner: Address, royalty_receiver: Address, royalty_basis: uint64): void
pay_assets:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Arc18.algo.ts:45
	// royalty_amount = this.royalty_amount(amount, royalty_basis)
	frame_dig -5 // royalty_basis: uint64
	frame_dig -2 // amount: uint64
	callsub royalty_amount
	frame_bury 0 // royalty_amount: uint64

	// contracts\Arc18.algo.ts:46
	// sendAssetTransfer({ assetReceiver: owner, assetAmount: amount - royalty_amount, xferAsset: asset, fee: 0 })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:46
	// assetReceiver: owner
	frame_dig -3 // owner: Address
	itxn_field AssetReceiver

	// contracts\Arc18.algo.ts:46
	// assetAmount: amount - royalty_amount
	frame_dig -2 // amount: uint64
	frame_dig 0 // royalty_amount: uint64
	-
	itxn_field AssetAmount

	// contracts\Arc18.algo.ts:46
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// contracts\Arc18.algo.ts:46
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if2_condition
	// contracts\Arc18.algo.ts:47
	// royalty_amount > 0
	frame_dig 0 // royalty_amount: uint64
	int 0
	>
	bz *if2_end

	// *if2_consequent
	// contracts\Arc18.algo.ts:48
	// sendAssetTransfer({ assetReceiver: royalty_receiver, assetAmount: royalty_amount, xferAsset: asset, fee: 0 })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:48
	// assetReceiver: royalty_receiver
	frame_dig -4 // royalty_receiver: Address
	itxn_field AssetReceiver

	// contracts\Arc18.algo.ts:48
	// assetAmount: royalty_amount
	frame_dig 0 // royalty_amount: uint64
	itxn_field AssetAmount

	// contracts\Arc18.algo.ts:48
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// contracts\Arc18.algo.ts:48
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if2_end:
	retsub

// update_offer_amount(owner: Address, asset: AssetID, new_amt: uint64): void
update_offer_amount:
	proto 3 0

	// contracts\Arc18.algo.ts:53
	// this.offers(owner, asset).value.offered_amount = new_amt
	frame_dig -1 // owner: Address
	frame_dig -2 // asset: AssetID
	itob
	app_local_get
	int 32 // headOffset
	frame_dig -3 // new_amt: uint64
	itob
	replace3
	frame_dig -1 // owner: Address
	frame_dig -2 // asset: AssetID
	itob
	uncover 2
	app_local_put
	retsub

// set_administrator(address)void
*abi_route_set_administrator:
	// new_admin: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (new_admin) for set_administrator must be a address
	assert

	// execute set_administrator(address)void
	callsub set_administrator
	int 1
	return

// set_administrator(new_admin: Address): void
set_administrator:
	proto 1 0

	// contracts\Arc18.algo.ts:57
	// assert(this.from_administrator(), 'Not an Admin')
	callsub from_administrator

	// Not an Admin
	assert

	// contracts\Arc18.algo.ts:58
	// this.administrator.value = new_admin
	byte 0x61646d696e6973747261746f72 // "administrator"
	frame_dig -1 // new_admin: Address
	app_global_put
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts\Arc18.algo.ts:62
	// this.administrator.value = this.txn.sender
	byte 0x61646d696e6973747261746f72 // "administrator"
	txn Sender
	app_global_put
	retsub

// set_policy(uint64,address)void
*abi_route_set_policy:
	// royalty_receiver: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (royalty_receiver) for set_policy must be a address
	assert

	// royalty_basis: uint64
	txna ApplicationArgs 1
	btoi

	// execute set_policy(uint64,address)void
	callsub set_policy
	int 1
	return

// set_policy(royalty_basis: uint64, royalty_receiver: Address): void
set_policy:
	proto 2 0

	// contracts\Arc18.algo.ts:66
	// assert(this.from_administrator(), 'Not an Admin')
	callsub from_administrator

	// Not an Admin
	assert

	// contracts\Arc18.algo.ts:67
	// assert(!this.royalty_basis.exists || !this.royalty_receiver.exists, 'Policy Has Already set')
	txna Applications 0
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get_ex
	swap
	pop
	!
	dup
	bnz *skip_or0
	txna Applications 0
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get_ex
	swap
	pop
	!
	||

*skip_or0:
	// Policy Has Already set
	assert

	// contracts\Arc18.algo.ts:68
	// assert(royalty_basis <= max_royalty_basis, 'Royality Basis Has Exceeded Max Value')
	frame_dig -1 // royalty_basis: uint64
	int 10000
	<=

	// Royality Basis Has Exceeded Max Value
	assert

	// contracts\Arc18.algo.ts:69
	// this.royalty_basis.value = royalty_basis
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	frame_dig -1 // royalty_basis: uint64
	app_global_put

	// contracts\Arc18.algo.ts:70
	// this.royalty_receiver.value = royalty_receiver
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	frame_dig -2 // royalty_receiver: Address
	app_global_put
	retsub

// set_payment_asset(uint64,bool)void
*abi_route_set_payment_asset:
	// is_allowed: bool
	txna ApplicationArgs 2
	dup
	len
	int 1
	==

	// argument 0 (is_allowed) for set_payment_asset must be a bool
	assert
	int 0
	getbit

	// payment_asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute set_payment_asset(uint64,bool)void
	callsub set_payment_asset
	int 1
	return

// set_payment_asset(payment_asset: AssetID, is_allowed: boolean): void
set_payment_asset:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\Arc18.algo.ts:74
	// assert(this.from_administrator(), 'Not an Admin')
	callsub from_administrator

	// Not an Admin
	assert

	// contracts\Arc18.algo.ts:75
	// is_opted = this.app.address.isOptedInToAsset(payment_asset)
	global CurrentApplicationAddress
	frame_dig -1 // payment_asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	frame_bury 0 // is_opted: bool

	// *if3_condition
	// contracts\Arc18.algo.ts:76
	// !is_opted && is_allowed
	frame_dig 0 // is_opted: bool
	!
	dup
	bz *skip_and0
	frame_dig -2 // is_allowed: boolean
	&&

*skip_and0:
	bz *if3_elseif1_condition

	// *if3_consequent
	// contracts\Arc18.algo.ts:77
	// sendAssetTransfer({ assetAmount: 0, assetReceiver: this.app.address, xferAsset: payment_asset })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:77
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// contracts\Arc18.algo.ts:77
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts\Arc18.algo.ts:77
	// xferAsset: payment_asset
	frame_dig -1 // payment_asset: AssetID
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if3_end

*if3_elseif1_condition:
	// contracts\Arc18.algo.ts:78
	// is_opted && !is_allowed
	frame_dig 0 // is_opted: bool
	dup
	bz *skip_and1
	frame_dig -2 // is_allowed: boolean
	!
	&&

*skip_and1:
	bz *if3_end

	// *if3_elseif1_consequent
	// contracts\Arc18.algo.ts:79
	// sendAssetTransfer({
	//         assetAmount: 0,
	//         assetReceiver: payment_asset.creator,
	//         assetCloseTo: payment_asset.creator,
	//         xferAsset: payment_asset,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:80
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// contracts\Arc18.algo.ts:81
	// assetReceiver: payment_asset.creator
	frame_dig -1 // payment_asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetReceiver

	// contracts\Arc18.algo.ts:82
	// assetCloseTo: payment_asset.creator
	frame_dig -1 // payment_asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetCloseTo

	// contracts\Arc18.algo.ts:83
	// xferAsset: payment_asset
	frame_dig -1 // payment_asset: AssetID
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if3_end:
	retsub

// transfer_algo_payment(uint64,uint64,address,address,address,pay,uint64)void
*abi_route_transfer_algo_payment:
	// current_offer_amount: uint64
	txna ApplicationArgs 6
	btoi

	// payment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (payment) for transfer_algo_payment must be a pay transaction
	assert

	// royalty_receiver: address
	txna ApplicationArgs 5
	dup
	len
	int 32
	==

	// argument 2 (royalty_receiver) for transfer_algo_payment must be a address
	assert

	// to: address
	txna ApplicationArgs 4
	dup
	len
	int 32
	==

	// argument 3 (to) for transfer_algo_payment must be a address
	assert

	// from: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 4 (from) for transfer_algo_payment must be a address
	assert

	// royalty_asset_amount: uint64
	txna ApplicationArgs 2
	btoi

	// royalty_asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute transfer_algo_payment(uint64,uint64,address,address,address,pay,uint64)void
	callsub transfer_algo_payment
	int 1
	return

// transfer_algo_payment(royalty_asset: AssetID, royalty_asset_amount: uint64, from: Address, to: Address, royalty_receiver: Address, payment: PayTxn, current_offer_amount: uint64): void
transfer_algo_payment:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts\Arc18.algo.ts:97
	// assert(this.royalty_basis.exists && this.royalty_receiver.exists, 'Policy Not set')
	txna Applications 0
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get_ex
	swap
	pop
	dup
	bz *skip_and2
	txna Applications 0
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get_ex
	swap
	pop
	&&

*skip_and2:
	// Policy Not set
	assert

	// contracts\Arc18.algo.ts:98
	// assert(this.offers(from, royalty_asset).exists, 'Royalty Asset Offer Not Available')
	frame_dig -3 // from: Address
	txna Applications 0
	frame_dig -1 // royalty_asset: AssetID
	itob
	app_local_get_ex
	swap
	pop

	// Royalty Asset Offer Not Available
	assert

	// contracts\Arc18.algo.ts:99
	// assert(globals.groupSize == 2, 'Group Size Must be 2')
	global GroupSize
	int 2
	==

	// Group Size Must be 2
	assert

	// contracts\Arc18.algo.ts:101
	// offer = this.offers(from, royalty_asset).value
	frame_dig -1 // royalty_asset: AssetID
	itob
	frame_bury 0 // storage key//offer

	// contracts\Arc18.algo.ts:101
	// offer = this.offers(from, royalty_asset).value
	frame_dig -3 // from: Address
	frame_bury 1 // storage account//offer

	// contracts\Arc18.algo.ts:102
	// saved_royalty_receiver = this.royalty_receiver.value
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get
	frame_bury 2 // saved_royalty_receiver: address

	// contracts\Arc18.algo.ts:103
	// saved_royalty_basis = this.royalty_basis.value
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get
	frame_bury 3 // saved_royalty_basis: uint64

	// contracts\Arc18.algo.ts:105
	// assert(offer.auth_address == this.txn.sender, 'Only Authorized Address can send this transaction')
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 0 32
	txn Sender
	==

	// Only Authorized Address can send this transaction
	assert

	// contracts\Arc18.algo.ts:106
	// assert(payment.rekeyTo == globals.zeroAddress, 'Rekeyed Accounts are Not Allowed')
	frame_dig -6 // payment: PayTxn
	gtxns RekeyTo
	global ZeroAddress
	==

	// Rekeyed Accounts are Not Allowed
	assert

	// contracts\Arc18.algo.ts:107
	// assert(royalty_asset_amount <= offer.offered_amount, 'Requested Amount is Greater than Offered Amount')
	frame_dig -2 // royalty_asset_amount: uint64
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	<=

	// Requested Amount is Greater than Offered Amount
	assert

	// contracts\Arc18.algo.ts:108
	// assert(royalty_receiver == saved_royalty_receiver, 'Royality Receiver Mismatched')
	frame_dig -5 // royalty_receiver: Address
	frame_dig 2 // saved_royalty_receiver: address
	==

	// Royality Receiver Mismatched
	assert

	// contracts\Arc18.algo.ts:109
	// assert(current_offer_amount == offer.offered_amount, 'Current Offer Amount Mismatch')
	frame_dig -7 // current_offer_amount: uint64
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	==

	// Current Offer Amount Mismatch
	assert

	// contracts\Arc18.algo.ts:110
	// verifyPayTxn(payment, {
	//       rekeyTo: globals.zeroAddress,
	//       closeRemainderTo: globals.zeroAddress,
	//       sender: offer.auth_address,
	//       receiver: this.app.address,
	//     })
	// verify rekeyTo
	frame_dig -6 // payment: PayTxn
	gtxns RekeyTo
	global ZeroAddress
	==

	// transaction verification failed: {"txn":"payment","field":"rekeyTo","expected":"globals.zeroAddress"}
	assert

	// verify closeRemainderTo
	frame_dig -6 // payment: PayTxn
	gtxns CloseRemainderTo
	global ZeroAddress
	==

	// transaction verification failed: {"txn":"payment","field":"closeRemainderTo","expected":"globals.zeroAddress"}
	assert

	// verify sender
	frame_dig -6 // payment: PayTxn
	gtxns Sender
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 0 32
	==

	// transaction verification failed: {"txn":"payment","field":"sender","expected":"offer.auth_address"}
	assert

	// verify receiver
	frame_dig -6 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\Arc18.algo.ts:117
	// this.pay_algos(payment.amount, from, royalty_receiver, saved_royalty_basis)
	frame_dig 3 // saved_royalty_basis: uint64
	frame_dig -5 // royalty_receiver: Address
	frame_dig -3 // from: Address
	frame_dig -6 // payment: PayTxn
	gtxns Amount
	callsub pay_algos

	// contracts\Arc18.algo.ts:119
	// sendAssetTransfer({
	//       assetAmount: royalty_asset_amount,
	//       assetReceiver: to,
	//       assetSender: from,
	//       fee: 0,
	//       xferAsset: royalty_asset,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:120
	// assetAmount: royalty_asset_amount
	frame_dig -2 // royalty_asset_amount: uint64
	itxn_field AssetAmount

	// contracts\Arc18.algo.ts:121
	// assetReceiver: to
	frame_dig -4 // to: Address
	itxn_field AssetReceiver

	// contracts\Arc18.algo.ts:122
	// assetSender: from
	frame_dig -3 // from: Address
	itxn_field AssetSender

	// contracts\Arc18.algo.ts:123
	// fee: 0
	int 0
	itxn_field Fee

	// contracts\Arc18.algo.ts:124
	// xferAsset: royalty_asset
	frame_dig -1 // royalty_asset: AssetID
	itxn_field XferAsset

	// Submit inner transaction
	itxn_submit

	// contracts\Arc18.algo.ts:127
	// this.update_offer_amount(from, royalty_asset, offer.offered_amount - royalty_asset_amount)
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	frame_dig -2 // royalty_asset_amount: uint64
	-
	frame_dig -1 // royalty_asset: AssetID
	frame_dig -3 // from: Address
	callsub update_offer_amount
	retsub

// transfer_asset_payment(uint64,uint64,address,address,address,axfer,uint64,uint64)void
*abi_route_transfer_asset_payment:
	// current_offer_amount: uint64
	txna ApplicationArgs 7
	btoi

	// payment_asset: uint64
	txna ApplicationArgs 6
	btoi

	// payment: axfer
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int axfer
	==

	// argument 2 (payment) for transfer_asset_payment must be a axfer transaction
	assert

	// royalty_receiver: address
	txna ApplicationArgs 5
	dup
	len
	int 32
	==

	// argument 3 (royalty_receiver) for transfer_asset_payment must be a address
	assert

	// to: address
	txna ApplicationArgs 4
	dup
	len
	int 32
	==

	// argument 4 (to) for transfer_asset_payment must be a address
	assert

	// from: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 5 (from) for transfer_asset_payment must be a address
	assert

	// royalty_asset_amount: uint64
	txna ApplicationArgs 2
	btoi

	// royalty_asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute transfer_asset_payment(uint64,uint64,address,address,address,axfer,uint64,uint64)void
	callsub transfer_asset_payment
	int 1
	return

// transfer_asset_payment(royalty_asset: AssetID, royalty_asset_amount: uint64, from: Address, to: Address, royalty_receiver: Address, payment: AssetTransferTxn, payment_asset: AssetID, current_offer_amount: uint64): void
transfer_asset_payment:
	proto 8 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts\Arc18.algo.ts:140
	// assert(this.royalty_basis.exists && this.royalty_receiver.exists, 'Policy Not set')
	txna Applications 0
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get_ex
	swap
	pop
	dup
	bz *skip_and3
	txna Applications 0
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get_ex
	swap
	pop
	&&

*skip_and3:
	// Policy Not set
	assert

	// contracts\Arc18.algo.ts:141
	// assert(this.offers(from, royalty_asset).exists, 'Royalty Asset Offer Not Available')
	frame_dig -3 // from: Address
	txna Applications 0
	frame_dig -1 // royalty_asset: AssetID
	itob
	app_local_get_ex
	swap
	pop

	// Royalty Asset Offer Not Available
	assert

	// contracts\Arc18.algo.ts:142
	// assert(globals.groupSize == 2, 'Group Size Must be 2')
	global GroupSize
	int 2
	==

	// Group Size Must be 2
	assert

	// contracts\Arc18.algo.ts:144
	// offer = this.offers(from, royalty_asset).value
	frame_dig -1 // royalty_asset: AssetID
	itob
	frame_bury 0 // storage key//offer

	// contracts\Arc18.algo.ts:144
	// offer = this.offers(from, royalty_asset).value
	frame_dig -3 // from: Address
	frame_bury 1 // storage account//offer

	// contracts\Arc18.algo.ts:145
	// saved_royalty_receiver = this.royalty_receiver.value
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get
	frame_bury 2 // saved_royalty_receiver: address

	// contracts\Arc18.algo.ts:146
	// saved_royalty_basis = this.royalty_basis.value
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get
	frame_bury 3 // saved_royalty_basis: uint64

	// contracts\Arc18.algo.ts:148
	// assert(offer.auth_address == this.txn.sender, 'Only Authorized Address can send this transaction')
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 0 32
	txn Sender
	==

	// Only Authorized Address can send this transaction
	assert

	// contracts\Arc18.algo.ts:149
	// assert(payment.rekeyTo == globals.zeroAddress, 'Rekeyed Accounts are Not Allowed')
	frame_dig -6 // payment: AssetTransferTxn
	gtxns RekeyTo
	global ZeroAddress
	==

	// Rekeyed Accounts are Not Allowed
	assert

	// contracts\Arc18.algo.ts:150
	// assert(royalty_asset_amount <= offer.offered_amount, 'Requested Amount is Greater than Offered Amount')
	frame_dig -2 // royalty_asset_amount: uint64
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	<=

	// Requested Amount is Greater than Offered Amount
	assert

	// contracts\Arc18.algo.ts:151
	// assert(royalty_receiver == saved_royalty_receiver, 'Royality Receiver Mismatched')
	frame_dig -5 // royalty_receiver: Address
	frame_dig 2 // saved_royalty_receiver: address
	==

	// Royality Receiver Mismatched
	assert

	// contracts\Arc18.algo.ts:152
	// assert(current_offer_amount == offer.offered_amount, 'Current Offer Amount Mismatch')
	frame_dig -8 // current_offer_amount: uint64
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	==

	// Current Offer Amount Mismatch
	assert

	// contracts\Arc18.algo.ts:153
	// verifyAssetTransferTxn(payment, {
	//       rekeyTo: globals.zeroAddress,
	//       sender: offer.auth_address,
	//       assetReceiver: this.app.address,
	//       xferAsset: payment_asset,
	//       assetCloseTo: globals.zeroAddress,
	//     })
	// verify rekeyTo
	frame_dig -6 // payment: AssetTransferTxn
	gtxns RekeyTo
	global ZeroAddress
	==

	// transaction verification failed: {"txn":"payment","field":"rekeyTo","expected":"globals.zeroAddress"}
	assert

	// verify sender
	frame_dig -6 // payment: AssetTransferTxn
	gtxns Sender
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 0 32
	==

	// transaction verification failed: {"txn":"payment","field":"sender","expected":"offer.auth_address"}
	assert

	// verify assetReceiver
	frame_dig -6 // payment: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify xferAsset
	frame_dig -6 // payment: AssetTransferTxn
	gtxns XferAsset
	frame_dig -7 // payment_asset: AssetID
	==

	// transaction verification failed: {"txn":"payment","field":"xferAsset","expected":"payment_asset"}
	assert

	// verify assetCloseTo
	frame_dig -6 // payment: AssetTransferTxn
	gtxns AssetCloseTo
	global ZeroAddress
	==

	// transaction verification failed: {"txn":"payment","field":"assetCloseTo","expected":"globals.zeroAddress"}
	assert

	// contracts\Arc18.algo.ts:161
	// this.pay_assets(payment_asset, payment.assetAmount, from, royalty_receiver, saved_royalty_basis)
	frame_dig 3 // saved_royalty_basis: uint64
	frame_dig -5 // royalty_receiver: Address
	frame_dig -3 // from: Address
	frame_dig -6 // payment: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -7 // payment_asset: AssetID
	callsub pay_assets

	// contracts\Arc18.algo.ts:163
	// sendAssetTransfer({
	//       assetAmount: royalty_asset_amount,
	//       assetReceiver: to,
	//       assetSender: from,
	//       fee: 0,
	//       xferAsset: royalty_asset,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\Arc18.algo.ts:164
	// assetAmount: royalty_asset_amount
	frame_dig -2 // royalty_asset_amount: uint64
	itxn_field AssetAmount

	// contracts\Arc18.algo.ts:165
	// assetReceiver: to
	frame_dig -4 // to: Address
	itxn_field AssetReceiver

	// contracts\Arc18.algo.ts:166
	// assetSender: from
	frame_dig -3 // from: Address
	itxn_field AssetSender

	// contracts\Arc18.algo.ts:167
	// fee: 0
	int 0
	itxn_field Fee

	// contracts\Arc18.algo.ts:168
	// xferAsset: royalty_asset
	frame_dig -1 // royalty_asset: AssetID
	itxn_field XferAsset

	// Submit inner transaction
	itxn_submit

	// contracts\Arc18.algo.ts:171
	// this.update_offer_amount(from, royalty_asset, offer.offered_amount - royalty_asset_amount)
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	frame_dig -2 // royalty_asset_amount: uint64
	-
	frame_dig -1 // royalty_asset: AssetID
	frame_dig -3 // from: Address
	callsub update_offer_amount
	retsub

// offer(uint64,uint64,address,uint64,address)void
*abi_route_offer:
	// offered_auth_addr: address
	txna ApplicationArgs 5
	dup
	len
	int 32
	==

	// argument 0 (offered_auth_addr) for offer must be a address
	assert

	// offered_amount: uint64
	txna ApplicationArgs 4
	btoi

	// auth_address: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 2 (auth_address) for offer must be a address
	assert

	// royalty_asset_amount: uint64
	txna ApplicationArgs 2
	btoi

	// royalty_asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute offer(uint64,uint64,address,uint64,address)void
	callsub offer
	int 1
	return

// offer(royalty_asset: AssetID, royalty_asset_amount: uint64, auth_address: Address, offered_amount: uint64, offered_auth_addr: Address): void
offer:
	proto 5 0

	// contracts\Arc18.algo.ts:181
	// assert(this.royalty_basis.exists && this.royalty_receiver.exists, 'Policy Not set')
	txna Applications 0
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get_ex
	swap
	pop
	dup
	bz *skip_and4
	txna Applications 0
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get_ex
	swap
	pop
	&&

*skip_and4:
	// Policy Not set
	assert

	// contracts\Arc18.algo.ts:182
	// assert(royalty_asset.clawback == this.app.address, "App doesn't have clawback on this asset")
	frame_dig -1 // royalty_asset: AssetID
	asset_params_get AssetClawback
	pop
	global CurrentApplicationAddress
	==

	// App doesn't have clawback on this asset
	assert

	// contracts\Arc18.algo.ts:183
	// assert(
	//       royalty_asset_amount >= this.txn.sender.assetBalance(royalty_asset),
	//       'Asset Amount provided is greater than asset Holding'
	//     )
	frame_dig -2 // royalty_asset_amount: uint64
	txn Sender
	frame_dig -1 // royalty_asset: AssetID
	asset_holding_get AssetBalance
	pop
	>=

	// Asset Amount provided is greater than asset Holding
	assert

	// contracts\Arc18.algo.ts:187
	// assert(
	//       royalty_asset.freeze == globals.zeroAddress || royalty_asset.freeze == this.app.address,
	//       'Invalid Freeze Value For asset'
	//     )
	frame_dig -1 // royalty_asset: AssetID
	asset_params_get AssetFreeze
	pop
	global ZeroAddress
	==
	dup
	bnz *skip_or1
	frame_dig -1 // royalty_asset: AssetID
	asset_params_get AssetFreeze
	pop
	global CurrentApplicationAddress
	==
	||

*skip_or1:
	// Invalid Freeze Value For asset
	assert

	// contracts\Arc18.algo.ts:191
	// assert(
	//       royalty_asset.manager == globals.zeroAddress || royalty_asset.manager == this.app.address,
	//       'Invalid Manager Value For asset'
	//     )
	frame_dig -1 // royalty_asset: AssetID
	asset_params_get AssetManager
	pop
	global ZeroAddress
	==
	dup
	bnz *skip_or2
	frame_dig -1 // royalty_asset: AssetID
	asset_params_get AssetManager
	pop
	global CurrentApplicationAddress
	==
	||

*skip_or2:
	// Invalid Manager Value For asset
	assert

	// contracts\Arc18.algo.ts:196
	// this.offers(this.txn.sender, royalty_asset).value = {
	//       auth_address: auth_address,
	//       offered_amount: royalty_asset_amount,
	//     }
	txn Sender
	frame_dig -1 // royalty_asset: AssetID
	itob
	frame_dig -3 // auth_address: Address
	frame_dig -2 // royalty_asset_amount: uint64
	itob
	concat
	app_local_put
	retsub

// royalty_free_move(uint64,uint64,address,address,uint64)void
*abi_route_royalty_free_move:
	// offered_amount: uint64
	txna ApplicationArgs 5
	btoi

	// to: address
	txna ApplicationArgs 4
	dup
	len
	int 32
	==

	// argument 1 (to) for royalty_free_move must be a address
	assert

	// from: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 2 (from) for royalty_free_move must be a address
	assert

	// royalty_asset_amount: uint64
	txna ApplicationArgs 2
	btoi

	// royalty_asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute royalty_free_move(uint64,uint64,address,address,uint64)void
	callsub royalty_free_move
	int 1
	return

// royalty_free_move(royalty_asset: AssetID, royalty_asset_amount: uint64, from: Address, to: Address, offered_amount: uint64): void
royalty_free_move:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Arc18.algo.ts:209
	// assert(this.offers(from, royalty_asset).exists, 'Royalty Asset Offer Not Available')
	frame_dig -3 // from: Address
	txna Applications 0
	frame_dig -1 // royalty_asset: AssetID
	itob
	app_local_get_ex
	swap
	pop

	// Royalty Asset Offer Not Available
	assert

	// contracts\Arc18.algo.ts:210
	// offer = this.offers(from, royalty_asset).value
	frame_dig -1 // royalty_asset: AssetID
	itob
	frame_bury 0 // storage key//offer

	// contracts\Arc18.algo.ts:210
	// offer = this.offers(from, royalty_asset).value
	frame_dig -3 // from: Address
	frame_bury 1 // storage account//offer

	// contracts\Arc18.algo.ts:211
	// assert(offer.offered_amount == offered_amount, 'Given Offered Amount is not same as in offer')
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	frame_dig -5 // offered_amount: uint64
	==

	// Given Offered Amount is not same as in offer
	assert

	// contracts\Arc18.algo.ts:212
	// assert(offered_amount >= royalty_asset_amount, 'requested amount is greater than offered amount')
	frame_dig -5 // offered_amount: uint64
	frame_dig -2 // royalty_asset_amount: uint64
	>=

	// requested amount is greater than offered amount
	assert

	// contracts\Arc18.algo.ts:213
	// assert(offer.auth_address == this.txn.sender, 'Only Authorized Address can send this transaction')
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 0 32
	txn Sender
	==

	// Only Authorized Address can send this transaction
	assert
	retsub

// get_policy()(address,uint64)
*abi_route_get_policy:
	// The ABI return prefix
	byte 0x151f7c75

	// execute get_policy()(address,uint64)
	callsub get_policy
	concat
	log
	int 1
	return

// get_policy(): [Address, uint64]
get_policy:
	proto 0 1

	// contracts\Arc18.algo.ts:217
	// assert(this.royalty_basis.exists && this.royalty_receiver.exists, 'Policy Not set')
	txna Applications 0
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get_ex
	swap
	pop
	dup
	bz *skip_and5
	txna Applications 0
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get_ex
	swap
	pop
	&&

*skip_and5:
	// Policy Not set
	assert

	// contracts\Arc18.algo.ts:218
	// return [this.royalty_receiver.value, this.royalty_basis.value];
	byte 0x726f79616c74795f7265636569766572 // "royalty_receiver"
	app_global_get
	byte 0x726f79616c74795f6261736973 // "royalty_basis"
	app_global_get
	itob
	concat
	retsub

// get_offer(uint64,address)(address,uint64)
*abi_route_get_offer:
	// The ABI return prefix
	byte 0x151f7c75

	// from: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (from) for get_offer must be a address
	assert

	// royalty_asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute get_offer(uint64,address)(address,uint64)
	callsub get_offer
	concat
	log
	int 1
	return

// get_offer(royalty_asset: AssetID, from: Address): [Address, uint64]
get_offer:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts\Arc18.algo.ts:222
	// assert(this.offers(from, royalty_asset).exists, "Offer Doesn't Exists")
	frame_dig -2 // from: Address
	txna Applications 0
	frame_dig -1 // royalty_asset: AssetID
	itob
	app_local_get_ex
	swap
	pop

	// Offer Doesn't Exists
	assert

	// contracts\Arc18.algo.ts:223
	// offer = this.offers(from, royalty_asset).value
	frame_dig -1 // royalty_asset: AssetID
	itob
	frame_bury 0 // storage key//offer

	// contracts\Arc18.algo.ts:223
	// offer = this.offers(from, royalty_asset).value
	frame_dig -2 // from: Address
	frame_bury 1 // storage account//offer

	// contracts\Arc18.algo.ts:224
	// return [offer.auth_address, offer.offered_amount];
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 0 32
	frame_dig 1 // storage account//offer
	frame_dig 0 // storage key//offer
	app_local_get
	extract 32 8
	btoi
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// get_administrator()address
*abi_route_get_administrator:
	// The ABI return prefix
	byte 0x151f7c75

	// execute get_administrator()address
	callsub get_administrator
	concat
	log
	int 1
	return

// get_administrator(): Address
get_administrator:
	proto 0 1

	// contracts\Arc18.algo.ts:228
	// return this.administrator.value;
	byte 0x61646d696e6973747261746f72 // "administrator"
	app_global_get
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "set_administrator(address)void"
	method "set_policy(uint64,address)void"
	method "set_payment_asset(uint64,bool)void"
	method "transfer_algo_payment(uint64,uint64,address,address,address,pay,uint64)void"
	method "transfer_asset_payment(uint64,uint64,address,address,address,axfer,uint64,uint64)void"
	method "offer(uint64,uint64,address,uint64,address)void"
	method "royalty_free_move(uint64,uint64,address,address,uint64)void"
	method "get_policy()(address,uint64)"
	method "get_offer(uint64,address)(address,uint64)"
	method "get_administrator()address"
	txna ApplicationArgs 0
	match *abi_route_set_administrator *abi_route_set_policy *abi_route_set_payment_asset *abi_route_transfer_algo_payment *abi_route_transfer_asset_payment *abi_route_offer *abi_route_royalty_free_move *abi_route_get_policy *abi_route_get_offer *abi_route_get_administrator

	// this contract does not implement the given ABI method for call NoOp
	err

*call_OptIn:
	method "optInToApplication()void"
	txna ApplicationArgs 0
	match *abi_route_optInToApplication

	// this contract does not implement the given ABI method for call OptIn
	err